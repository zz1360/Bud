# 数据结构和算法

### java数据结构

数据结构指的是存储数据的结构。数据存储的常用结构有：***栈、队列、数组、链表和红黑树***。

Java中有几种常用的数据结构，主要分为Collection和map两个主要接口（接口只提供方法，并不提供实现），而程序中最终使用的数据结构是继承自这些接口的数据结构类。

 

##### 栈

栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。

简单的说：采用该结构的集合，对元素的存取有如下的特点:

先进后出（存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。

栈的入口、出口的都是栈的顶端位置。

需要注意的 2 个名词

​	压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。

​	弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。

<img src="/img/clip_image002.jpg">

 

##### 队列

队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。

简单的说，采用该结构的集合，对元素的存取有如下的特点：

先进先出（存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。

队列的入口、出口各占一侧。

<img src="/img/clip_image004.jpg">

 

##### 数组

数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。

简单的说,采用该结构的集合，对元素的存取有如下的特点：

​	查找元素快：通过索引，可以快速访问指定位置的元素

​	增删元素慢

指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。

指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。

**Java中Vector和ArrayList底层是数组结构**

 

#####  链表

链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。

每个结点包括两个部分：

一个是存储数据元素的数据域，

一个是存储下一个结点地址的指针域。

链表结构有单向链表与双向链表。

采用该结构的集合，对元素的存取有如下的特点：

多个结点之间，通过地址进行连接。

​	查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。

​	增删元素快：增加元素：只需要修改连接下个元素的地址即可。

删除元素：只需要修改连接下个元素的地址即可。

**Java中LinkedList底层是链表结构（还是双向链表）**

 

##### 红黑树

二叉树：binary tree ,是每个结点不超过2的有序树（tree）。

简单的理解，就是一种类似于树的结构，只不过每个结点上都最多只能有两个子结点。

二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。

<img src="/img/clip_image006.jpg">

二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。

红黑树的约束:

​	节点可以是红色的或者黑色的

​	根节点是黑色的

​	叶子节点(特指空节点)是黑色的

​	每个红色节点的子节点都是黑色的

​	任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

 

红黑树的特点:

​	速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍。

**Java中TreeSet和TreeMap底层数据结构是红黑树结构**

### 算法

编写一段计算机程序一般都是实现一种已有的方法解决某个问题。这种方法大多和使用的编程语言无关——它使用于各种计算机以及编程语言。是这种方法，而非计算机程序本身描述了解决问题的步骤，在计算机科学，我们用**算法**这个词来描述**一种有限、确定、有效的并适合用计算机程序来实现解决问题的方法**。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

##### 时间复杂度

1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C * f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C * f(n)。其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n2+n +1) = O (3n2+n+3) = O (7n2 + n) = O ( n2 ) ，一般都只用O(n2)表示就可以了。注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。

在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)

##### 空间复杂度

类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\"进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如下面介绍的快速排序和归并排序算法就属于这种情况。

如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

##### 排序算法

算法一门高深的学科，常见的算法有排序算法、查找算法、图算法、字符串算法，这里由于篇幅有限，所以只介绍一下排序算法，其它的算法有兴趣可以去研究。

元素的排序是非常重要的基础算法，相关的算法研究的比较熟练，有插入排序，选择排序，希尔排序，快速排序，归并排序，堆排序，桶排序、冒泡排序。下面介绍几种常见的排序（示例都是从小到大排序）。

**冒泡排序**

思路：

1.  比较相邻的元素。如果第一个比第二个大，就交换他们两个。 
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

代码：

```java
public static int[] bubbleSort(int[] a) {
   		int N = a.length;
   		for (int i = 0; i < N - 1; i++) {
     	//小的数字向上冒泡
			for (int j= N-1; j > i; j--) {
       	//交换位置
				if	(a[j-1]>a[j]){
         			int tmp;
         			tmp = a[i];
         			a[i] = a[j];
         			a[j] = tmp;
       			}
     		}
   		}
   		return a;
 	}  

```

冒泡算法的改进：

改进部分就是，如果在第二层for循环中，如果不发生交换，则代表数据已经排好序了，不需要继续排序。

优化代码：

```java
 public static int[] bubbleSort2(int[] a) {
     int n = a.length;
     boolean flag = true;
     for(int i = 0;i < n - 1 && flag; i++) {
         int j = n - 1;
         for(flag = false; j > i; j--) {
             if (a[j-1] > a[j]) {
                 flag = true;
                 int tmp;
                 tmp = a[j];
         		 a[j] = a[j-1];
         		 a[j-1] = tmp;;
             }
         }
     }
     return a;
 }

```



假如数组的长度是N，则时间复杂度：

进行比较的次数：(N-1)+(N-2)+……+1 = N(N-1)/2

进行交换的次数：N

特点：（稳定）

运行时间与输入无关。因为前一次的扫描并不能为后面的提供信息。

数据的移动次数是最小的。

 

**选择排序**

思路：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

代码：

```java
public static int[] selectionSort(int a[]){
   		int min;
   		for (int i=0;i<a.length;i++){
     	min = i;
      //这个for循环是为了找出最小的值
     	for (int j = i+1; j < a.length; j++) {
        	if(a[min]>a[j]){
       		   min = j;
      	    }
        }
     /*如果第一个取出的元素不是最小值，就进行交换
       意思就是：如果取出的元素就是最小值，那么就没有必要进行交换了*/
	    if(min != i){
       //* *进行交换
	      int tmp;
       	  tmp = a[i];
          a[i] = a[min];
          a[min] = tmp;
     }
   }
   return a;
 }
```



**快速排序**

思路：快速排序使用分治法（Divide and conquer）策略来把一个序列分为较小和较大的2个子序列（首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分），然后递归地排序两个子序列。

代码：(我这代码是随机快速排序)

```java
public static void quickSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		quickSort(arr, 0, arr.length - 1);
	}

	public static void quickSort(int[] arr, int l, int r) {
		if (l < r) {
			swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
			int[] p = partition(arr, l, r);
			quickSort(arr, l, p[0] - 1);
			quickSort(arr, p[1] + 1, r);
		}
	}

	public static int[] partition(int[] arr, int l, int r) {
		int less = l - 1;
		int more = r;
		while (l < more) {
			if (arr[l] < arr[r]) {
				swap(arr, ++less, l++);
			} else if (arr[l] > arr[r]) {
				swap(arr, --more, l);
			} else {
				l++;
			}
		}
		swap(arr, more, r);
		return new int[] { less + 1, more };
	}
```

快速排序在最坏的情况下时间复杂度是O(n2),平均时间复杂度是O(nlogn)。快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。