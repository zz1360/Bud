>  java代码编译执行过程

　　1.源码编译：通过Java源码编译器将Java代码编译成JVM字节码（.class文件）

　　2.类加载：通过ClassLoader及其子类来完成JVM的类加载

​	    3.类执行：字节码被装入内存，进入JVM虚拟机，被解释器解释执行

# JVM

(1)java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行

(2)Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统、硬件无关的关键。

　　 JVM的下方是***移植接口***，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器，JVM 通过移植接口在具体的平台和操作系统上实现

　　 JVM 的上方是***Java的基本类库和扩展类库以及它们的API***， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台

　 　Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的跨平台

(3)JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了

(4)三种JVM：① Sun公司的HotSpot ② BEA公司的JRockit ③ IBM公司的J9 JVM

　　在JDK1.7及其以前我们所使用的都是Sun公司的HotSpot，但由于Sun公司和BEA公司都被oracle收购，jdk1.8将采用Sun公司的HotSpot和BEA公司的JRockit两个JVM中精华形成jdk1.8的JVM。

### JVM体系介绍

##### Class Loader类加载器

负责加载 .class文件，class文件在文件开头有特定的文件标示，并且ClassLoader负责class文件的加载等，至于它是否可以运行，则由Execution Engine决定。

　　① 定位和导入二进制class文件

　　② 验证导入类的正确性

　　③ 为类分配初始化内存

　　④ 帮助解析符号引用.

##### Native Interface本地接口

　　本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体作法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。

　　目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见。

　　因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等。

##### Execution Engine 执行引擎

执行包在装载类的方法中的指令，也就是方法。

##### Runtime data area 运行数据区

即：虚拟机内存或者JVM内存 下面介绍

从整个计算机内存中开辟一块内存存储Jvm需要用到的对象，变量等，分为：***方法区，堆，虚拟机栈，程序计数器，本地方法栈***。

##### JVM内存结构

<img src="/img/clip_image002.jpg">

##### 程序计数器 PC Register

每个线程都有一个程序计算器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

##### 本地方法栈 Native Method Stack

　　Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies

　　本地方法栈与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务

##### 方法区 Method Area

　　用于存储虚拟机加载的：***静态变量+常量+类信息+运行时常量池*** （类信息：类的版本、字段、方法、接口、构造函数等描述信息 ）

默认最小值为16MB，最大值为64MB，可以通过***-XX:PermSize*** 和 ***-XX:MaxPermSize*** 参数限制方法区的大小

##### 栈 JVM Stack

编译器可知的各种***基本数据类型***(boolean、byte、char、short、int、float、long、double)、***对象引用***(引用指针，并非对象本身)，

***栈是java 方法执行的内存模型***：

　　每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。

每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

栈的生命期是跟随线程的生命期，线程创建时创建，线程结束栈内存也就释放，是线程私有的。

#####  堆 Java Heap

　　所有的对象实例以及数组都要在堆上分配，此内存区域的唯一目的就是存放对象实例

堆是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，***在虚拟机启动时创建***。

堆是理解Java GC机制最重要的区域，没有之一

　　结构：新生代（Eden区+2个Survivor区） 老年代  永久代（HotSpot有）

　　***新生代***：新创建的对象——>Eden区 

　　		GC之后：存活的对象由Eden区 Survivor区0进入Survivor区1  

　　		再次GC，存活的对象由Eden区 Survivor区1进入Survivor区0 

　　***老年代***：对象如果在新生代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到老年代

　　如果新创建对象比较大（比如长字符串或大数组），新生代空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）

　　老年代的空间一般比新生代大，能存放更多的对象，在老年代上发生的GC次数也比年轻代少

​	   ***永久代***：可以简单理解为方法区（本质上两者并不等价）

Jdk1.6及之前：常量池分配在永久代

Jdk1.7：有，但已经逐步“去永久代”

Jdk1.8及之后：没有永久代(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)

##### 直接内存 Direct Memor

直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存

JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用

由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。

### 类加载

##### 类的加载过程

当使用java命令运行java程序时，此时JVM启动，并去方法区下找java命令后面跟的类是否存在，如果不存在，则把类加载到方法区下

在类加载到方法区时，会分为两部分：先加载非静态内容到方法区下的非静态区域内，再加载静态内容到方法区下的静态区域内-------***先非后静***

当非静态内容载完成之后，就会加载所有的静态内容到方法区下的静态区域内

(1) 先把所有的静态内容加载到静态区域下

(2) 所有静态内容加载完之后，对所有的静态成员变量进行默认初始化

(3) 当所有的静态成员变量默认初始化完成之后，再对所有的静态成员变量显式初始化

(4) 当所有的静态成员变量显式初始化完成之后，JVM自动执行静态代码块（静态代码块在栈中执行）[如果有多个静态代码，执行的顺序是按照代码书写的先后顺序执行]

(5) 所有的静态代码块执行完成之后，此时类的加载完成

##### 对象的创建过程

当在main方法中创建对象时，JVM会先去方法区下找有没有所创建对象的类存在，有就可以创建对象了，没有则把该类加载到方法区

在创建类的对象时，首先会先去堆内存中开辟一块空间，开辟完后分配该空间(指定地址)

当空间分配完后，加载对象中所有的非静态成员变量到该空间下

所有的非静态成员变量加载完成之后，对所有的非静态成员进行默认初始化

所有的非静态成员默认初始化完成之后，调用相应的构造方法到栈中

在栈中执行构造函数时，先执行隐式，再执行构造方法中书写的代码

 构造方法中的隐式：

​		第一步：执行super()语句   调用父类的没有参数的构造方法

​		第二步：对所有的非静态成员变量进行显式初始化（在定义成员变量时后面有赋值）

​		第三步：所有的非静态成员变量显式初始化完成之后，执行构造代码块

​		Ps.第二步第三步按照书写顺序执行

 最后执行构造方法中书写的代码

当整个构造方法全部执行完，此对象创建完成，并把堆内存中分配的空间地址赋给对象名（此时对象名就指向了该空间）

##### ClassLoader类加载机制

概念：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制



***哪些场景会触发类加载***

1.new关键字实例化对象时、读取或者设置一个类的静态字段时、以及调用一个类的静态方法的时候如果类没有进行过初始化，则需要先触发其初始化。

2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要触发父类的初始化。

4.当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的类），虚拟机会先初始化这个类

整个生命周期包括：

**加载、验证、准备、解析、初始化、使用和卸载七个阶段。**



类加载器分类（必会）

**Bootstrap ClassLoader**

**Extension ClassLoader**

**Application ClassLoader**



***双亲委派模型***

如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
可以看一段代码：

以java.lang包下的ClassLoader为例，loadClass的实现如下：

```java
 public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    //              -----??-----
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
 
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
/*
那么如果有一个Hello.class文件是如何被加载到JVM中的呢？
当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理会先检查自己是否已经加载过，如果没有再往上。注意这个过程，知道到达Bootstrap classLoader之前，都是没有哪个加载器自己选择加载的。如果父加载器无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。
*/
```



##### Java中堆和栈的区别

stack 空间小，速度比较快， 用来放对象的引用 

heep 大，一般所有创建的对象都放在这里。

栈(stack):是一个先进后出的数据结构,通常用于保存方法(函数)中的参数,局部变量. 

在java中,所有基本类型和引用类型都在栈中存储.栈中数据的生存空间一般在当前scopes内(就是由{...}括起来的区域). 

堆(heap):是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护),C中的malloc语句所产生的内存空间就在堆中. 

在java中,所有使用new xxx()构造出来的对象都在堆中存储,当垃圾回收器检测到某对象未被引用,则自动销毁该对象.所以,理论上说java中对象的生存空间是没有限制的,只要有引用类型指向它,则它就可以在任意地方被使用. 

 

\1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 

\2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

\3. ***Java中的数据类型有两种。***

一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。 这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 

另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： 

int a = 3; 

int b = 3；

编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。

这样，就出现了a与b同时均指向3的情况。特别注意的是，这种字面值的引用与类对象的引用不同。 

假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。

相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。 如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

### gc简介

垃圾收集 Garbage Collection 通常被称为“GC”

理解GC机制就从：**“GC**的区域在哪里”，“GC的对象是什么”，“GC的时机是什么”，“GC做了哪些事”几方面来分析。

##### 需要GC的内存区域

jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收***主要集中于 java 堆和方法区***中，在程序运行期间，这部分内存的分配和使用都是动态的。

##### GC的对象

需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。

（1）引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

（2）可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

##### 什么时候触发GC

(1)程序调用System.gc时可以触发

(2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）

GC又分为 minor GC 和 Full GC (也称为 Major GC )

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

 a.调用System.gc时，系统建议执行Full GC，但是不必然执行

 b.老年代空间不足

 c.方法区空间不足

 d.通过Minor GC后进入老年代的平均大小大于老年代的可用内存

 e.由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

##### GC做了什么事

 主要做了清理对象，整理内存的工作。**Java堆分为新生代和老年代**，采用了不同的回收方式。（GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。**目前主流的JVM（HotSpot）采用的是分代收集算法**。）

##### Java内存泄露及引起原因

首先，什么是内存泄露？内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。

那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。具体主要有如下几大类： 

1.静态集合类引起内存泄露(提高)

像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 

例: 

```java
Static Vector v = new Vector(10);

for (int i = 1; i<100; i++) 

{ 

Object o = new Object(); 

v.add(o); 

o = null; 

}
```

在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。

2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。

例： 

```java
//先说前提，这段代码要想成功，必须重写Person类的equals和hashcode方法，不然无法成功

public static void main(String[] args) {
        Set<Person> set = new HashSet<Person>();

        Person p1 = new Person("唐僧","pwd1",25);

        Person p2 = new Person("孙悟空","pwd2",26);

        Person p3 = new Person("猪八戒","pwd3",27);

        set.add(p1);

        set.add(p2);

        set.add(p3);

        System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素!
        
        System.out.println(p3.hashCode());

        p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变

        System.out.println(p3.hashCode());

        set.remove(p3); //此时remove不掉，造成内存泄漏，remove是通过hash值

        set.add(p3); //重新添加，居然添加成功

        System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素!

        for (Person person : set) {

            System.out.println(person);

        }
    }
```

3、监听器 

在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。

4、各种连接 

比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但***Connection 一定要显式回收***，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。***但是***如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。

5、内部类和外部模块等的引用 

内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：

public void registerMsg(Object b); 

这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。

6、单例模式 

不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子： 

```java
class A{ 

	public A(){ 

	B.getInstance().setA(this); 

	} 

	.... 

} 

//B类采用单例模式 

class B{ 

	private A a; 

	private static B instance=new B(); 

	public B(){} 

	public static B getInstance(){ 

	return instance; 

	} 

	public void setA(A a){ 

	this.a=a; 

	} 

//getter... 

} 
```

显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况