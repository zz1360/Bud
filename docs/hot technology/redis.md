# redis基本知识

### redis概述

【redis是什么？】数据库分为关系数据库和键值数据库 redis在本质上是键值数据库

1. xml配置文件中配置bean（JedisPool/JedisCluster）,再配置属性注入指定redis的host和port，集群的话需要指定每一个redis的host和port，在配置一个bean（自己写的JedisClient接口）
2. 【面向接口编程】项目中JedisClient接口工具类的书写

【接口】写一个JedisClient接口，接口中有set、get、hset、hget、hdel、expire等常用方法；

【实现类】分别用集群版的JedisClientCluster和单机版的JedisClientPool去实现，并重写方法，各自用自己的方					式实现功能；

【调用】在管理redis的时候，我们只需要@AutoWired（只打开一个得情况下）注入接口，只需要调用接口里的				方法，不用管调用的是集群版还是单机版的，这个可以在配置文件中控制。

【存值】项目中存的时候用的是存hash值，一个key，对应一个map（key，value）；redis可以存五种类型的数				据（string,list,hash,set,sortedset）；因为加入存入的是string的简单的key/value类型，不同表的id可				能会重复，所以在最前面要添加一个商品的大的类目作为区分

【应用逻辑】在查询一个商品的时候先查redis缓存，如果有取缓存，如果没有，查数据库，同步缓存；当数据库						跟新的时候，进行redis缓存的id覆盖/删除

### java管理redis

​    1)通过jedis

​		单机版的通过JedisPool获取一个Jedis对象来set、get管理，用完需要关闭Jedis

​		集群版的通过JedisCluster来set、get管理

​    2)通过spring data redis，项目中这种

### Redis五种数据类型（不能存储对象）

1.String：key-value（做缓存）

​    常用命令:

   get /set /incr加一/decr减一

2.Hash：key-fields-values（做缓存）

​    (相当于一个key对应一个map,map中还有key-value)

​    常用命令:

​    hset:从hash中添加内容/hget:从hash中取内容

​    hset hash1 field3 3 /hget hash1 field3 

3.List：有顺序可重复

​    常用命令:

​    添加:lpush/rpush/ 

​    查看:lrange list1 0 -1/ 

​    取删:lpop/ rpop 

4.Set：无顺序，不能重复

​    常用命令:

​    添加:sadd set1 a b c c c d

​    查看:smembers set1 

​    删除:srem set1 a 

5.SortedSet（zset）：有顺序，不能重复

​    常用命令:

​    分数添加:zadd zset1 2 a 5 b 1 c 6 d 

​    分数查看:zrange zset1 0 -1 

​    删除:zrem zset1 a 

​    反过来顺序查看:zrevrange zset1 0 -1

### key命令

​	设置10秒钟过期: expire key 秒

​	查看过期时间(s) : ttl key

​	设置持久化: persist key ,

​	ttl key值为-1,意思为持久保存,值为-2,意思是不存在/已经删掉了

### Redis持久化

​	RDB持久化（默认方式）

​	该机制是指在制定的时间间隔内将内存中的数据集**快照**写入磁盘。

​	优点：  1.只有一份rdb文件，可随时备份

​				  2.比AOF文件小，加载效率高

​				  3.只提供fork子进程，不阻塞主进程，IO操作比较少

​	AOF持久化

​		该机制将以**日志**的形式记录服务器所处理的每一个写操作，在Redis服务器启动之初会读取该文件来重新构建		数据库，以保证启动后数据库中的数据是完整的。

​	优点：  1.每次改动同步数据安全性好

​				  2.APPEND方式追加日志，不会对旧日志文件产生影响

​	无持久化

​		我们可以通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的		memcached了

***同时应用AOF和RDB（推荐用）***

用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，可以使用RDB进行快速的数据恢复。

# redis集群知识

### redis集群

集群指的是将几台服务器集中在一起，实现同一业务

目的：高可用、负载均衡、易扩展、数据安全、性能提升

技术：集群地址（虚拟IP）、网络通信（监控消息）

功能：负载均衡、读写分离、故障转移

### 怎样判断redis服务是否正常？

ping-pong机制来判断节点是否挂了

启动./redis-service redis.conf(后台运行) 

客户端：./reids-cli -h -p (默认6379）来连接

还可以通过哨兵模式监控（多了解下哨兵模式）

### 架构细节

(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化速度和带宽.

(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.

(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster负责维护

(5)每个节点存储的数据不一样，但每个节点都会有备份机，主从机存储一样的数据

集群如何存储数据

Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点

### redis集群搭建过程（使用ruby脚本搭建集群）

​	-->删除aof和rdb文件

​	-->安装ruby和ruby使用的脚本包redis-gem 

​	--> 得到redis-trib.rb，用它来创建集群

### 常问问题

##### 为什么redis的查询速度比mysql数据库快?

1.存在物理内存中

2.是键值数据库，本身具有简单快捷的特点

**redis是怎样存入磁盘的？**

dump.rdb和appendonly.aof两个配置文件【rdbaof热带暴风】

RDB:在指定时间间隔内将内存中的数据集快照写入磁盘（默认）

AOF：以日志的形式将记录服务器的每一个操作

 

##### 为什么redis集群中必须至少有三个节点?

​    一个节点挂了,有一半以上的节点通过ping-pong方式的投票机制认为它挂了,那么这个集群就挂了.但如果只有2个节点,有一个挂了,另一个确定它挂了但百分比只占到了50%,没有超过一半,这个集群也不会挂,所以至少需要3个节点；

##### 为什么每个redis集群需要至少6台服务器?

因为redis集群至少需要三个节点,要保证集群的高可用,每个节点都要一个备份机.理论上也需要6台虚拟机

##### redis优缺点

Redis的**优点**？

​	**性能极高** – Redis能支持超过 100K+ 每秒的读写频率。
​    **丰富的数据类型** – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
​    **原子** – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
​    **丰富的特性** – Redis还支持 publish/subscribe, 通知, key 过期等等特性。

​	**Redis相比其它缓存**，他有两种持久化机制，RDB和AOF，数据更安全。

Redis的**缺点**？

​	是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据	量的高性能操作和运算上。

##### 一致性哈希算法

一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。twemproxy也选择这种算法，解决将key-value均匀分配到众多 server上的问题。它可以取代传统的取模操作，解决了取模操作应对增删 Server的问题。-----`关于一致性哈希的具体讲解看算法专题`

**简单步骤**

\1. 先用hash算法将对应的节点ip哈希到一个具有2^32次方个桶的空间中，即0~（2^32）-1的数字空间。现在我们可以将这些数字头尾相连，连接成一个闭合的环形：

\2. 当用户在客户端进行请求时候，首先根据key计算路由hash值，然后看hash值落到了hash环的哪个地方，根据hash值在hash环上的位置顺时针找距离最近的节点：

\3. 当新增节点的时候，和之前的做法一样，只需要把受到影响的数据迁移到新节点即可

\4. 当移除节点的时候，和之前的做法一样，把移除节点的数据，迁移到顺时针距离最近的节点

​    从上面的步骤可以看出，当节点个数变动时，使用哈希一致性映射关系失效的对象非常少，迁移成本也非常小。那么判断一个哈希算法好坏的指标有哪些呢？以下列出了4个指标：

**\* 平衡性（Balance）：**

   平衡性是指哈希的结果能够尽可能分散到不同的缓存服务器上去，这样可以使得所有的服务器得到利用。一致性hash可以做到每个服务器都进行处理理请求，但是不能保证每个服务器处理的请求的数量大致相同

**\* 单调性（Monotonicity）：**

   单调性是指如果已经有一些请求通过哈希分派到了相应的服务器进行处理，又有新的服务器加入到系统中时候，哈希的结果应保证原有的请求可以被映射到原有的或者新的服务器中去，而不会被映射到原来的其它服务器上去。

**\* 分散性（Spread）：**

   分布式环境中，客户端请求时候可能不知道所有服务器的存在，可能只知道其中一部分服务器，在客户端看来他看到的部分服务器会形成一个完整的hash环。如果多个客户端都把部分服务器作为一个完整hash环，那么可能会导致，同一个用户的请求被路由到不同的服务器进行处理。这种情况显然是应该避免的，因为它不能保证同一个用户的请求落到同一个服务器。所谓分散性是指上述情况发生的严重程度。好的哈希算法应尽量量避免尽量降低分散性。 而一致性hash具有很低的分散性。

##### 使用过Redis做异步队列么，你是怎么用的？有什么缺点？

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

缺点：

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

##### 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？

**缓存穿透**

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

如何避免？

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。

2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。

**缓存雪崩**

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

如何避免？

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

##### Redis为什么是单线程的

单纯的网络IO来说，量大到一定程度之后，多线程的确有优势——但并不是单纯的多线程，而是每个线程自己有自己的epoll这样的模型，也就是多线程和multiplexing混合。一般这个开头我们都会跟一个“但是”。但是。还要考虑Redis操作的对象。它操作的对象是内存中的数据结构。如果在多线程中操作，那就需要为这些对象加锁。最终来说，多线程性能有提高，但是每个线程的效率严重下降了。而且程序的逻辑严重复杂化。要知道Redis的数据结构并不全是简单的KeyValue，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。些操作还可以合成MULTI/EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。

Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。

并不是所有的KV数据库或者内存数据库都应该用单线程，比如ZooKeeper就是多线程的，最终还是看作者自己的意愿和取舍。单线程的威力实际上非常强大，每核心效率也非常高，在今天的虚拟化环境当中可以充分利用云化环境来提高资源利用率。多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的，所以单线程、多进程的集群不失为一个时髦的解决方案。

##### redis的通信协议是什么？

Redis 的通讯协议是文本协议，是的，Redis 服务器与客户端通过 RESP(Redis Serialization Protocol)协议通信。

没错，文本协议确实是会浪费流量，不过它的优点在于直观，非常的简单，解析性能极其的好

我们不需要一个特殊的 Redis 客户端仅靠 Telnet 或者是文本流就可以跟 Redis 进行通讯。

客户端的命令格式：

简单字符串 Simple Strings，以 "+"加号开头。

错误 Errors，以"-"减号开头。

整数型 Integer，以 ":" 冒号开头。

大字符串类型 Bulk Strings，以 "$"美元符号开头。

数组类型 Arrays，以 "*"星号开头。

set hello abc一个简单的文本流就可以是redis的客户端

<img src="/img/redis-1.png">

简单总结：具体可以见：

https://redis.io/topics/protocol ，

Redis 文档认为简单的实现，快速的解析，直观理解是采用 **RESP 文本协议**最重要的地方，有可能文本协议会造成一定量的流量浪费，但却在性能上和操作上快速简单，这中间也是一个权衡和协调的过程。

##### redis使用场景

传智健康项目：利用redis来保存图片名称，区分哪些是垃圾图片，这里使用set类型，具体做法为：

1、当用户上传图片后，将图片名称保存到redis的一个Set集合中，例如集合名称为setmealPicResources

2、当用户添加套餐后，将图片名称保存到redis的另一个Set集合中，例如集合名称为setmealPicDbResources

3、计算setmealPicResources集合与setmealPicDbResources集合的差值，结果就是垃圾图片的名称集合，清理这些图片即可

 

十次方项目：评论管理中，用redis保存点赞信息，点赞信息利用用评论id+用户id进行标识。每次点赞的时候都会在redis中查看是否已经点赞

 

商城项目：当并发量比较高，频繁的对数据库进行读操作的时候都需要添加缓存。例如页面中广告数据、搜索面板数据、购物车等都是redis实现的，使用的redis的hash类型的数据。另外注册功能是使用redis’存放手机验证码（刚好redis可以设置key的过期时间，做验证码比较合适）

##### 如何提高缓存的利用率？

做数据的缓存时，因为数据量很大，而且缓存是把数据保存到内存中，此时不可能把所有的数据都放到缓存中。所以需要设置数据缓存的有效期，当用户访问到非热点数据后，此数据放到缓存中，当缓存到期后就从缓存中删除，而且长时间不会添加到缓存。而热点数据一旦从缓存中删除会马上又添加到缓存。这样可以提高缓存的利用率，同时也减轻了数据库的压力。

##### 项目中使用到了缓存，那么如何实现缓存同步的？

只要使用了缓存就涉及到缓存同步的问题。缓存同步其实就是当缓存的信息发生变化，也就是对后台对缓存的数据进行增、删、改操作后，数据库中的数据发生了变化同时要把缓存中的数据对应删除即可。当页面再次请求数据时，缓存中不能命中就会从数据库中查询并且添加到缓存中，即实现了缓存同步。

##### redis事物，了解CAS(check-and-set 操作实现乐观锁 )?

和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出

Redis中

事务的实现特征：

1). 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。

2). **和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。**

3). 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为"BEGIN TRANSACTION"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。

4). 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。

5). 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。

Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部

分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了