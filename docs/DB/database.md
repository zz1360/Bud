#  Sql之连接查询

***外连接：***

​	1）***左连接（左外连接）***以左表为基准进行查询,左表数据会全部显示出来,右表如果和左表匹配的数据则显示相	应字段的数据,如果不匹配,则显示为NULL;

​	2）***右连接（右外连接）***以右表为基准进行查询,右表数据会全部显示出来,右表如果和左表匹配的数据则显示相	应字段的数据,如果不匹配,则显示为NULL;

​	3）***全连接***就是先以左表进行左外连接，然后以右表进行右外连接。



**内连接**：显示表之间有连接匹配的所有行。



#  Sql之聚合函数

聚合函数是对一组值执行计算并返回单一的值的函数，它经常与SELECT语句的GROUP BY子句一同使用。

1).AVG 返回指定组中的平均值，空值被忽略； COUNT 返回指定组中项目的数量。
 例：`select prd_no,avg(qty) from sales group by prd_no`

 2). MAX 返回指定数据的最大值；MIN 返回指定数据的最小值；SUM 返回指定数据的和，只能用于数字列，空值被忽略。
 例：`select prd_no,max(qty) from sales group by prd_no `

3）使用group by 子句对数据进行分组；对group by 子句形成的组运行聚集函数计算每一组的值；最后用having 子句去掉不符合条件的组；***having 子句中的每一个元素也必须出现在select列表中***。有些数据库例外，如oracle.

例：`select prd_no,max(qty) from sales group by prd_no having prd_no>10`

# Sql之SQL注入

举例：

`select admin from user where username='admin' or 'a'='a' and passwd=''or 'a'='a'`

防止SQL注入，使用预编译语句是预防SQL注入的最佳方式，如

`select admin from user where username=？And password=?`

使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号`？`表示。像上面例子中，username变量传递的'admin' or 'a'='a' 参数，也只会当作username字符串来解释查询，从根本上杜绝了SQL注入攻击的发生。

 

***注意：使用mybaits时 mapper中#方式能够很大程度防止sql注入，$方式无法防止sql注入.***

# SQL Select语句完整的执行顺序

***from--->where--->group by--->having--->计算所有的表达式--->order by--->select输出***

# 什么是存储过程？它有什么优点？

答：存储过程是一组预编译的SQL语句，

***它的优点有：***

允许模块化程序设计，就是说只需要创建一次过程，以后在程序中就可以调用该过程任意次。

允许更快执行，如果某操作需要执行大量SQL语句或重复执行，存储过程比SQL语句执行的要快。

减少网络流量，例如一个需要数百行的SQL代码的操作有一条执行语句完成，不需要在网络中发送数百行代码。

更好的安全机制，对于没有权限执行存储过程的用户，也可授权他们执行存储过程。

***MySQL存储过程的创建（了解）***

```mysql
(1). 格式

MySQL存储过程创建的格式：

CREATE PROCEDURE存储过程名(参数列表)

BEGIN

​    SQL语句代码块

END

举例：
  CREATE PROCEDURE proc1(OUT s int)  

  BEGIN 

   SELECT COUNT(*) INTO s FROM user;  

  END 

(2). 参数：   MySQL 存储过程参数有三种类型：in、out、inout。

如果仅仅想把数据传给 MySQL存储过程，那就使用“in”类型参数；如果仅仅从 MySQL存储过程返回值，那就使用“out”类型参数；如果需要把数据传给 MySQL存储过程，还要经过一些计算后再传回给我们，此时，要使用“inout”类型参数。

(3). Mysql调用储存过程

  Set @n=1      //声明变量

  Call procName(@n) //调用储存过程 
```

**注**：存储过程就是一些sql编程，类似java中的代码块。面试时如问到，可回答，存储过程用sql写了很多的业务逻辑，这样偏离了sql原有的初衷，我们公司更倾向于将业务逻辑写在代码中，所以我们都不写存储过程。

#  mysql性能优化

***一：优化说明：数据库优化的几个方面***

<img src="/img/clip_image002.jpg">

可以看出来，数据结构、SQL、索引是成本最低，且效果最好的优化手段。

注：性能优化是无止境的，当性能可以满足需求时即可，不要过度优化。

 

二：优化方向

***\1. SQL以及索引的优化***

首先要根据需求写出结构良好的SQL，然后根据SQL在表中建立有效的索引。但是如果索引太多，不但会影响写入的效率，对查询也有一定的影响。



***\2. 合理的数据库是设计***

根据数据库三范式来进行表结构的设计。设计表结构时，就需要考虑如何设计才能更有效的查询。

数据库三范式：

第一范式：数据表中每个字段都必须是不可拆分的最小单元，也就是确保每一列的原子性；

第二范式：满足一范式后，表中每一列必须有唯一性，都必须依赖于主键；

第三范式：满足二范式后，表中的每一列只与主键直接相关而不是间接相关(外键也是直接相关)，字段没有冗余。

注意：没有最好的设计，只有最合适的设计，所以不要过分注重理论。三范式可以作为一个基本依据，不要生搬硬套。

有时候可以根据场景合理地反规范化：

A：分割表。

B：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。

C：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间。

 

数据库五大约束：

A：PRIMARY key:设置主键约束；

B：UNIQUE：设置唯一性约束，不能有重复值；

C：DEFAULT 默认值约束

D：NOT NULL：设置非空约束，该字段不能为空；

E：FOREIGN key :设置外键约束。

 

字段类型选择：

A：尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED

B：VARCHAR的长度只分配真正需要的空间

C：使用枚举或整数代替字符串类型

D：尽量使用TIMESTAMP而非DATETIME

E：单表不要有太多字段，建议在20以内

F：避免使用NULL字段，很难查询优化且占用额外索引空间



***\3. 系统配置的优化***

例如：MySQL数据库my.cnf



***\4. 硬件优化***

更快的IO、更多的内存。一般来说内存越大，对于数据库的操作越好。但是CPU多就不一定了，因为他并不会用到太多的CPU数量，有很多的查询都是单CPU。另外使用高的IO（SSD、RAID），但是IO并不能减少数据库锁的机制。所以说如果查询缓慢是因为数据库内部的一些锁引起的，那么硬件优化就没有什么意义。

 

三：优化方案

***代码优化***

之所以把代码放到第一位，是因为这一点最容易引起技术人员的忽视。很多技术人员拿到一个性能优化的需求以后，言必称缓存、异步、JVM等。实际上，第一步就应该是分析相关的代码，找出相应的瓶颈，再来考虑具体的优化策略。有一些性能问题，完全是由于代码写的不合理，通过直接修改一下代码就能解决问题的，比如for循环次数过多、作了很多无谓的条件判断、相同逻辑重复多次等。

举个栗子：

一个update操作，先查询出entity，再执行update，这样无疑多了一次数据库交互。还有一个问题，update语句可能会操作一些无需更新的字段。

我们可以将表单中涉及到的属性，以及updateTime，updateUser等赋值到entity，直接通过updateByPrimaryKeySelective，去update特定字段。

定位慢SQL，并优化

这是最常用、每一个技术人员都应该掌握基本的SQL调优手段（包括方法、工具、辅助系统等）。这里以MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。

具体优化手段：

A：尽量少用（或者不用）数据库自带的函数

select id from t where substring(name,1,3) = ’abc’

select id from t where datediff(day,createdate,’2005-11-30′) = 0

可以这样查询：

select id from t where name like ‘abc%’

select id from t where createdate >= ‘2005-11-30’ and createdate < ‘2005-12-1’

 

B：连续数值条件，用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5

C：Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗

D：尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型

E：不建议使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。尽量避免向客户 端返回大数据量，若数据量过大，应该考虑相应需求是否合理

F：表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能

G：select count(*) from table；这样不带任何条件的count会引起全表扫描

**连接池调优**

我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数。

**合理使用索引**

索引一般情况下都是高效的。但是由于索引是以空间换时间的一种策略，索引本身在提高查询效率的同时会影响插入、更新、删除的效率，频繁写的表不宜建索引。

 

选择合适的索引列，选择在where，group by，order by，on从句中出现的列作为索引项，对于离散度不大的列没有必要创建索引。

主键已经是索引了，所以primay key 的主键不用再设置unique唯一索引

**索引类型**

主键索引 （PRIMARY KEY）

唯一索引 （UNIQUE）

普通索引 （INDEX）

组合索引 （INDEX）

全文索引 （FULLTEXT）

 

可以应用索引的操作符

***大于等于***

***Between***

***IN***

***LIKE 不以 % 开头***

不能应用索引的操作符

***NOT IN***

***LIKE %_ 开头***

如何选择索引字段

A：字段出现在查询条件中，并且查询条件可以使用索引

B：通常对数字的索引和检索要比对字符串的索引和检索效率更高

C：语句执行频率高，一天会有几千次以上

D：通过字段条件可筛选的记录集很小

**无效索引**

A：尽量不要在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

B：应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。

C：应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描

select id from t where num=10 or Name = ‘admin’

可以这样查询：

select id from t where num = 10

union

select id from t where Name = ‘admin’

union all 返回所有数据，不管是不是重复。 union会自动压缩，去除重复数据。

D：不做列运算

where age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等

E：查询like，如果是 ‘%aaa’ 不会使用到索引

 

索引的按底层数据结构分为B+树索引和哈希索引（详情请查阅相关文档，这里不做拓展）

 

[**mysql****分库分表**](http://wentao365.iteye.com/blog/1740874)**：**

分库分表有垂直切分和水平切分两种。
 垂直切分：即将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库workDB、商品数据库payDB、用户数据库userDB、日志数据库logDB等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。
 水平切分：当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。
 3.3 应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。
 如果数据库是因为表太多而造成[海量数据](https://www.baidu.com/s?wd=海量数据&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Yvnjm1m10dn1RLP1RvmvFh0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0YPWDsnHbznHf1PWmsnjf4rf)，并且项目的各项[业务逻辑](https://www.baidu.com/s?wd=业务逻辑&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Yvnjm1m10dn1RLP1RvmvFh0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0YPWDsnHbznHf1PWmsnjf4rf)划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。
 而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。
 在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行水平切分。

 

单库多表 ：

  随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。 
 可以将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 

多库多表 ：

随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。 

分库分表规则举例：

  通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是user_id除以4的方式，当用户新注册了一个账号，账号id的123,我们可以通过id 除以4的方式确定此账号应该保存到User_0003表中。当用户123登录的时候，我们通过123 除以4后确定记录在User_0003中。

mysql读写分离：

 在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂Slave,通过此方式可以有效的提高DB集群的每秒查询率. 

 所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 
 此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。 
 所以，1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。 2. 当写压力很大的时候，就必须得进行分库操作。 

 

**选择正确的存储引擎**

Mysql 中 有两种存储引擎，MyISAM 和 InnoDB。

区别：

InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；

InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；

如何选择：

是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；

如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。

系统奔溃后，MyISAM恢复起来更困难，能否接受；

MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

 

**使用缓存（redis/Ehche）**

使用场景
 短时间内相同数据重复查询多次且数据更新不频繁，这个时候可以选择先从缓存查询，查询不到再从数据库加载并回设到缓存的方式。此种场景较适合用单机缓存。
 高并发查询热点数据，后端数据库不堪重负，可以用缓存来扛。

#  什么是事务？

[事务ACID特性](http://www.cnblogs.com/wangchuanqi/p/5554708.html)

 所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。

　 数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。

　 原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

　 一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。

　 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

　 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

　　事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。

　　数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。

 

在@Transactional注解中，可以propagation属性用来配置事务传播，支持7种不同的传播机制：

REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。

隔离级别：

<img src="/img/clip_image004.jpg">

Read uncommitted

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据

Read committed

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

Repeatable read

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

这个默认隔离级别是与具体的数据库相关的
 采取的是具体数据库的默认隔离级别
 不同的数据库是不一样的

#  mysql分页和oracle分页有什么不同？

Mysql中使用limit函数，limit有两种方式。

1）limit a,b 后缀两个参数的时候（/*参数必须是一个整数常量*/），其中a是指记录开始的偏移量,b是指从第a+1条开始，取b条记录。

2）limit b 后缀一个参数的时候，是直接取值到第多少位,类似于：limit 0,b 。

Oracle中

**使用rownum**，两种如下： 第一种： select * from (select t.*,rownum row_num from mytable t) b where b.row_num between 1 and 10 第二种： select * from ( select a.*, rownum rn from mytable a where rownum <= 10 ) where rn >= 1 

使用rowid， 如下： select * from scott.emp where rowid in (select rd from (select rowid as rd ,rownum as rn from scott.emp ) where rn<=6 and rn>3)