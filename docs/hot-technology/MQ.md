# **MQ专题**

### JMS介绍

JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范。JMS 本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统，类似于 JDBC。常见的消息队列有rabbitMQ，activMQ，kafka，rocketMQ

**JMS 定义了五种不同的消息正文格式：**

• TextMessage--一个字符串对象【常用】

• MapMessage--一套名称-值对【常用】

• ObjectMessage--一个序列化的 Java 对象

• BytesMessage--一个字节的数据流

• StreamMessage -- Java 原始值的数据流

**JMS消息传递的类型**

对于消息的传递有两种类型：

一种是点对点的，即一个生产者和一个消费者一一对应；

<img src="/img/mq-1.png">

另一种是发布/ 订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。

<img src="/img/mq-2.png">

### RabbitMQ

##### 什么是RabbitMQ？

RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然.

RabbitMQ本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了一个经纪人(Broker)构架，这意味着消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。

##### RabbitMQ的优点

基于erlang语言开发具有高可用高并发的优点，适合集群服务器。

健壮、稳定、易用、跨平台、支持多种语言、文档齐全。

有消息确认机制和持久化机制，可靠性高。

开源

其他MQ的优势：

Apache ActiveMQ曝光率最高，但是可能会丢消息。

ZeroMQ延迟很低、支持灵活拓扑，但是不支持消息持久化和崩溃恢复。

##### RabbitMQ的工作原理

下图是RabbitMQ的基本结构：

<img src="/img/mq-3.png">

组成部分说明如下：

Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。

Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。

Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。

Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。

Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。

消息发布接收流程：

-----发送消息-----

​	1、生产者和Broker建立TCP连接。

​	2、生产者和Broker建立通道。

​	3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。

​	4、Exchange将消息转发到指定的Queue（队列）

----接收消息-----

​	1、消费者和Broker建立TCP连接

​	2、消费者和Broker建立通道

​	3、消费者监听指定的Queue（队列）

​	4、当有消息到达Queue时Broker默认将消息推送给消费者。

​	5、消费者接收到消息。

### AcitveMQ

#####  ActiveMQ简介

ActiveMQ 是 Apache 下的一个子项目。 类似于 ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于 RabbitMQ，它少量代码就可以高效地实现高级应用场景。

***AcitveMQ的作用、原理？***（生产者。消费者。 p2p、订阅实现流程）

Activemq的作用就是系统之间进行通信。当然可以使用其他方式进行系统间通信，如果使用Activemq的话可以对系统之间的调用进行解耦，实现系统间的异步通信。原理就是生产者生产消息，把消息发送给activemq。Activemq接收到消息，然后查看有多少个消费者，然后把消息转发给消费者，此过程中生产者无需参与。消费者接收到消息后做相应的处理和生产者没有任何关系。

### 消息中间件的作用

消息队列的作用是无非三个，解耦，异步、削峰

##### 解耦

解除了程序的耦合性。在项目启动之初是很难预测未来会遇到什么困难的，消息中间件在处理过程中插入了一个隐含的，基于数据的接口层，两边都实现这个接口，这样就允许独立的修改或者扩展两边的处理过程，只要两边遵守相同的接口约束即可。

##### 异步通信

通过把把消息发送给消息中间件，消息中间件并不立即处理它，后续在慢慢处理。

##### 削峰

在访问量剧增的情况下，但是应用仍然需要发挥作用，但是这样的突发流量并不常见。而使用消息中间件采用队列的形式可以减少突发访问压力，不会因为突发的超时负荷要求而崩溃

### MQ面试常见问题

##### 如何防止消息重复发送？或者说，如何保证消息消费时的幂等性？

解决方法很简单：增加消息状态表。通俗来说就是一个账本，用来记录消息的处理状态，每次处理消息之前，都去状态表中查询一次，如果已经有相同的消息存在，那么不处理，可以防止重复发送。

##### 消息中间件的应用场景

开发中消息队列通常有如下应用场景：

1、任务异步处理。

将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。

2、应用程序解耦合

MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。

如，十次方项目中：使用rabbitMQ

学成在线：项目中cms页面发布接口执行页面静态化成功后，向消息队列发送页面发布的消息。页面发布的最终目标是将页面发布到服务器。通过消息队列将页面发布的消息发送给各各服务器。

电商项目：MQ在项目中主要是完成系统之间通信，并且将系统之间的调用进行**解耦**。例如在添加、修改商品信息后，需要将商品信息同步到索引库、同步缓存中的数据以及生成静态页面一系列操作。在此场景下就可以使用MQ。一旦后台对商品信息进行修改后，就向activeMQ发送一条消息，然后通过MQ将消息发送给消息的消费端，消费端接收到消息可以进行相应的业务处理。另外就是用户注册时，向用户发送短信验证码，采用queue方式通信。消费端可以调用阿里大于接口进行短信的发送。

##### ActiveMQ如果数据提交不成功怎么办？

Activemq有两种通信方式，点到点形式和发布订阅模式。如果是点到点模式的话，如果消息发送不成功此消息默认会保存到activemq服务端直到有消费者将其消费，所以此时消息是不会丢失的。

如果是发布订阅模式的通信方式，默认情况下只通知一次，如果接收不到此消息就没有了。这种场景只适用于对消息送达率要求不高的情况。如果要求消息必须送达不可以丢失的话，需要配置持久订阅。每个订阅端定义一个id，在订阅是向activemq注册。发布消息和接收消息时需要配置发送模式为持久化。此时如果客户端接收不到消息，消息会持久化到服务端，直到客户端正常接收后为止。

##### 如何保证消息的可靠性传输？要是消息丢失了怎么办？

数据的丢失问题，可能出现在生产者、MQ、消费者中

生产者丢失：生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前**开启 RabbitMQ 事务**channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。吞吐量会下来，因为太耗性能。所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以**开启confirm模式**，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息RabbitMQ 接收了之后会异步回调你一个接口通知你这个消息接收到了。所以一般在生产者这块避免数据丢失，都是用confirm机制的。

MQ中丢失：就是 RabbitMQ 自己弄丢了数据，这个你必须**开启 RabbitMQ 的持久化**，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。设置持久化有两个步骤：创建 queue 的时候将其设置为持久化，这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是不会持久化 queue 里的数据。第二个是发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。

消费端丢失：你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。这个时候得用 RabbitMQ 提供的ack机制，简单来说，就是你关闭 RabbitMQ 的自动ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。这样的话，如果你还没处理完，不就没有ack？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

<img src="/img/mq-4.png">

##### 如何保证消息顺序性

先看看顺序会错乱的场景：RabbitMQ：一个 queue，多个 consumer，这不明显乱了；

<img src="/img/mq-5.png">

解决：

<img src="/img/mq-6.png">